\documentclass{article} % For LaTeX2e
\usepackage{hyperref}
\usepackage{url}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage[numbers,sort]{natbib}
\usepackage{graphicx}
\usepackage[export]{adjustbox}
\usepackage{footmisc}
\usepackage[section]{placeins}
\usepackage{minted}
\DeclareGraphicsExtensions{.pdf,.png,.jpg,.eps}

\newlength\tindent
\setlength{\tindent}{\parindent}
\setlength{\parindent}{0pt}
\renewcommand{\indent}{\hspace*{\tindent}}


\author{
Gabriel C-Parent\\
}


\newcommand{\fix}{\marginpar{FIX}}
\newcommand{\new}{\marginpar{NEW}}

\begin{document}


\title{IFT6751: Homework 2}
      
\maketitle
\section{Introduction}

In this homework, two different approaches to solve the capacitated vehicle routing problem (CVRP) were designed. The first one is a genetic algorithm using specialized crossover and mutation operators whereas the the second one uses the Tabu Search to control local search with the $\lambda$-interchange neighbourhood.\newline

Two greedy local search methods are used within both methods to improve the results such as the 2-opt descent and  and the $\lambda$-interchange descent.\newline

Another method based on the Clark \& Wright savings is also used to initialize solutions for both metaheuristics.\newline


Both methods were tested against problem instances without length limit, from \citep{christofides} and compared to the best known solutions.\newline


A description of all the optimization methods along with special implementation details is given.
Some experimental results are then compared based on running time, implementation complexity and results quality.



\newpage
\section{Local search methods}
\label{local_search}


\subsection{2-opt descent}

First, a simple and fast optimization method for the TSP was needed to improve the path of each routes.

The local search method used to optimize individual routes is the steepest improvement method as described in \citep{steepest_improvement}.
Basically, it is a greedy use of the well known 2-opt method.\newline

At each iteration, the best possible 2-opt is chosen, according to the reduction in total distance, until there isn't any possible improvement. The complexity of the procedure $O(n^{2})$ on the number of edges in the route.\newline

Although it might seem slow, usually the number of edges is quite small and the time spent optimizing routes is relatively negligible.\newline

Simplified python code can be seen in the code section \ref{code_steepest_improvement}.


\subsection{$\lambda$-interchange descent}
Another optimization method was needed to exchange clients between routes, in this case the $\lambda$-interchange descent with $\lambda$=1 \citep{osman1993}.\newline

The possible transitions are the transfer of a client from a route to another and the swap of two clients between two routes. Since only feasible solutions are considered, only transitions that do not violate the capacity limit are considered.\newline

The procedure chooses the interchange with best possible improvement and applies it. Then the 2-opt descent is applied to the modified routes and the process is repeated until it gets stuck in a local minima.


\newpage
\section{Random Savings Initialization}

The Clark \& Wright savings algorithm is a well known simple heuristic for the CVRP.
Many improvements were suggested for this heuristic \cite{clark_wright_ds}.\newline

The one used in this work is a slight variant of the parallel savings, where instead of choosing the best the best saving and merging the corresponding routes, the $k$ best savings are found and one is randomly chosen.\newline

This procedure is used in both the Tabu Search and Genetic Algorithm procedures.\newline

In the Genetic Algorithm procedure, the random savings is used to generate good initial solutions. The initialization step is costly but the quality of the initial population is great.\newline

In the Tabu Search procedure, the random savings is used to initialize a solution, which is then locally explored until convergence is achieved.


\newpage
\section{Genetic Algorithm}
\label{genetic_algorithm}
%encodage d’une solution, sélection, croisement, mutation, remplacement de la population, critère d’arrêt

\subsection{Encoding}

The solutions are encoded using the Route object. Basically, a route is a list of clients that starts at the depot and ends at the depot, where no client is repeated. The solution is a list of routes, where each client is in exactly one route.

This representation isn't really friendly to classical crossover operators but allows functions defined on routes and solutions to be shared for both the Tabu Search and Genetic Algorithm representations.

\subsection{Objective function}

The objective function is the minimization of the total distance of the routes.

\begin{equation*}
\begin{aligned}
& \text{minimize}
& & \sum\limits_{r \in solution} distance(r) \\
& \text{subject to}
& & weight(r) \leq vehicle\ capacity
\end{aligned}
\end{equation*}

\subsection{Selection}

The simple well known binary tournament selection is used to select the parents of the next generation.

\subsection{Crossover}

The crossover used here is related to the concept of petals.
Basically, the

\subsection{Mutation}



\subsection{Population swap}



\subsection{Stopping criteria}


\newpage
\section{Tabu search}
\label{tabu_search}
%espace des solutions admissibles, fonction objectif, voisinage,
%liste tabou, critères d’aspiration, intensification, diversification, critère d’arrêt

With minor variations, the Tabu Search implemented was the same as in \citep{osman1993}.

\subsection{Solution space}

Only feasible solutions are considered, that is those not violating the capacity constraint.


\subsection{Objective function}

The objective function is the minimization of the total distance of the routes.

\begin{equation*}
\begin{aligned}
& \text{minimize}
& & \sum\limits_{r \in solution} distance(r) \\
& \text{subject to}
& & weight(r) \leq vehicle\ capacity
\end{aligned}
\end{equation*}


\subsection{Neighbourhood of a solution}

The neighbourhood of a solution is all the feasible solutions that can be reached by applying the $\lambda$-interchange, with $\lambda$=1.


\subsection{Tabu list}



\subsection{Asipration criteria}



\subsection{Intensification}



\subsection{Diversification}

The diversification strategy used here is to restart the Tabu Search with a new solution created by random savings.


\subsection{Stopping criteria}

As with the genetic algorithm, the stopping criteria can be a set number of iterations or a time limit, depending on the type of constraints the user has.


%------------------------------------------------------------------------------
\newpage
\section{Experimental results}
\label{exp_results}

%\subsection{}

%\begin{figure}[!htb]
%\begin{center}
% \includegraphics[scale=0.45]{MAP1000_stoplist}
% \caption{\small  Mean Average Precision at 1000 documents for treatments using the stoplist. Each column represents the topics set (1-50, 51-100, 101-150) and each row a different treatment. There are 4 non-dominated treatments over the three sets of queries: $krovetz\_dirichlet\_2000$, $porter\_dirichlet\_2000$, $krovetz\_okapi$ and $porter\_okapi$.}
% \label{mapstoplist}
% \end{center}
%\end{figure}



\section{Analysis of experimental results}
\label{analysis_results}


\subsection{Genetic Algorithm}



\subsection{Tabu Search}



\subsection{Non-dominated treatments}



%------------------------------------------------------------------------------
\section{Conclusion}



\bibliographystyle{plain}

\bibliography{dev2}

\newpage
\section{Code example}

\subsection{2-opt descent}
\label{code_steepest_improvement}
\begin{minted}[mathescape,
               linenos,
               numbersep=5pt,
               frame=lines,
               framesep=2mm]{python}

def steepest_improvement(route, dist):
    """steepest improvement procedure, using 2-opt"""
    best_ind1 = 0
    best_ind3 = 0
    savings = 0.
    proposed_savings = 0.
    # iterate until there isn't any better local choice (2-opt)
    while True:
        savings = 0.
        for ind1 in range(0, len(route.nodes)-2):
            for ind3 in range(ind1+2, len(route.nodes)-1):
                n1 = route.nodes[ind1]
                n2 = route.nodes[ind1 + 1]
                n3 = route.nodes[ind3]
                n4 = route.nodes[ind3+1]
                actual = dist[n1][n2] + dist[n3][n4]
                proposed = dist[n1][n3] + dist[n2][n4]
                proposed_savings = actual - proposed
                if proposed_savings > savings:
                    best_ind1 = ind1
                    best_ind3 = ind3
                    savings = proposed_savings
        if savings > 0.:
        	# do the 2-opt exchange
            two_opt(route, best_ind1, best_ind3)
        else:
            return
    return
\end{minted}

\end{document}


